// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_types = require("rescript/lib/js/js_types.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var Exception = /* @__PURE__ */Caml_exceptions.create("S-ReScriptStruct.Error.Internal.Exception");

function raise(expected, received, initialPathOpt, param) {
  var initialPath = initialPathOpt !== undefined ? initialPathOpt : "";
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: {
            TAG: /* UnexpectedValue */2,
            expected: expected === undefined ? "undefined" : JSON.stringify(expected),
            received: received === undefined ? "undefined" : JSON.stringify(received)
          },
          p: initialPath
        },
        Error: new Error()
      };
}

function raise$1(code) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: code,
          p: ""
        },
        Error: new Error()
      };
}

function toParseError(internalError) {
  var path = internalError.p;
  var tmp = path === "" ? [] : path.split(",");
  return {
          operation: /* Parsing */1,
          code: internalError.c,
          path: tmp
        };
}

function toSerializeError(internalError) {
  var path = internalError.p;
  var tmp = path === "" ? [] : path.split(",");
  return {
          operation: /* Serializing */0,
          code: internalError.c,
          path: tmp
        };
}

function prependLocation(error, $$location) {
  var path = error.p;
  var tmp = path === "" ? $$location : "" + $$location + "," + path + "";
  return {
          c: error.c,
          p: tmp
        };
}

function panic($$location) {
  throw new Error("[rescript-struct] " + ("For a " + $$location + " either a parser, or a serializer is required") + "");
}

function panic$1(param) {
  throw new Error("[rescript-struct] Unreachable");
}

function prependLocation$1(error, $$location) {
  return {
          operation: error.operation,
          code: error.code,
          path: [$$location].concat(error.path)
        };
}

function raiseCustom(error) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: error.code,
          p: error.path.toString()
        },
        Error: new Error()
      };
}

function raise$2(message) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          c: {
            TAG: /* OperationFailed */0,
            _0: message
          },
          p: ""
        },
        Error: new Error()
      };
}

function toReason(nestedLevelOpt, error) {
  var nestedLevel = nestedLevelOpt !== undefined ? nestedLevelOpt : 0;
  var reason = error.code;
  if (typeof reason === "number") {
    switch (reason) {
      case /* MissingParser */0 :
          return "Struct parser is missing";
      case /* MissingSerializer */1 :
          return "Struct serializer is missing";
      case /* UnexpectedAsync */2 :
          return "Encountered unexpected asynchronous transform or refine. Use parseAsyncWith instead of parseWith";
      
    }
  } else {
    switch (reason.TAG | 0) {
      case /* OperationFailed */0 :
          return reason._0;
      case /* UnexpectedType */1 :
      case /* UnexpectedValue */2 :
          break;
      case /* TupleSize */3 :
          return "Expected Tuple with " + reason.expected.toString() + " items, received " + reason.received.toString() + "";
      case /* ExcessField */4 :
          return "Encountered disallowed excess key \"" + reason._0 + "\" on an object. Use Deprecated to ignore a specific field, or S.Object.strip to ignore excess keys completely";
      case /* InvalidUnion */5 :
          var lineBreak = "\n" + " ".repeat((nestedLevel << 1)) + "";
          var array = reason._0.map(function (error) {
                var reason = toReason(nestedLevel + 1, error);
                var nonEmptyPath = error.path;
                var $$location = nonEmptyPath.length !== 0 ? "Failed at " + (
                    nonEmptyPath.length !== 0 ? nonEmptyPath.map(function (pathItem) {
                              return "[" + pathItem + "]";
                            }).join("") : "root"
                  ) + ". " : "";
                return "- " + $$location + "" + reason + "";
              });
          var reasons = Array.from(new Set(array));
          return "Invalid union with following errors" + lineBreak + "" + reasons.join(lineBreak) + "";
      
    }
  }
  return "Expected " + reason.expected + ", received " + reason.received + "";
}

function toString(error) {
  var match = error.operation;
  var operation = match ? "parsing" : "serializing";
  var reason = toReason(undefined, error);
  var path = error.path;
  var pathText = path.length !== 0 ? path.map(function (pathItem) {
            return "[" + pathItem + "]";
          }).join("") : "root";
  return "Failed " + operation + " at " + pathText + ". Reason: " + reason + "";
}

var Raised = /* @__PURE__ */Caml_exceptions.create("S-ReScriptStruct.Raised");

function planSyncTransformation(ctx, transformation) {
  var prevSyncTransformation = ctx.s;
  var prevAsyncTransformation = ctx.a;
  var match = ctx.p;
  if (match !== 1) {
    if (match !== 0) {
      ctx.a = (function (input) {
          return prevAsyncTransformation(input).then(transformation);
        });
    } else {
      ctx.p = /* OnlySync */1;
      ctx.s = transformation;
    }
  } else {
    ctx.s = (function (input) {
        return transformation(prevSyncTransformation(input));
      });
  }
}

function planAsyncTransformation(ctx, transformation) {
  var prevAsyncTransformation = ctx.a;
  var match = ctx.p;
  if (match !== 1) {
    if (match !== 0) {
      ctx.a = (function (input) {
          return prevAsyncTransformation(input).then(transformation);
        });
    } else {
      ctx.p = /* OnlyAsync */2;
      ctx.a = transformation;
    }
  } else {
    ctx.p = /* SyncAndAsync */3;
    ctx.a = transformation;
  }
}

function empty(param, param$1) {
  
}

function compile(transformationFactory, struct) {
  var ctx = {
    p: /* NoTransformation */0,
    s: undefined,
    a: undefined
  };
  transformationFactory(ctx, struct);
  var match = ctx.p;
  switch (match) {
    case /* NoTransformation */0 :
        return /* NoOperation */0;
    case /* OnlySync */1 :
        return {
                TAG: /* SyncOperation */0,
                _0: ctx.s
              };
    case /* OnlyAsync */2 :
        return {
                TAG: /* AsyncOperation */1,
                _0: (function (input) {
                    return function () {
                      return ctx.a(input);
                    };
                  })
              };
    case /* SyncAndAsync */3 :
        return {
                TAG: /* AsyncOperation */1,
                _0: (function (input) {
                    var syncOutput = ctx.s(input);
                    return function () {
                      return ctx.a(syncOutput);
                    };
                  })
              };
    
  }
}

function classify(struct) {
  return struct.t;
}

function name(struct) {
  return struct.n;
}

function getParseOperation(struct) {
  var parseOperationState = struct.r;
  if (typeof parseOperationState !== "number") {
    return parseOperationState;
  }
  if (parseOperationState === 2) {
    return {
            TAG: /* SyncOperation */0,
            _0: (function (input) {
                return struct.p(input);
              })
          };
  }
  if (parseOperationState === 3) {
    return {
            TAG: /* AsyncOperation */1,
            _0: (function (input) {
                return struct.a(input);
              })
          };
  }
  struct.r = parseOperationState === 1 ? 3 : 2;
  var compiledParseOperation = compile(struct.pf, struct);
  struct.r = compiledParseOperation;
  return compiledParseOperation;
}

function getSerializeOperation(struct) {
  var serializeOperationState = struct.e;
  if (typeof serializeOperationState !== "number") {
    return serializeOperationState;
  }
  if (serializeOperationState === 1) {
    return (function (input) {
              return struct.s(input);
            });
  }
  struct.e = 1;
  var fn = compile(struct.sf, struct);
  var compiledSerializeOperation;
  compiledSerializeOperation = typeof fn === "number" ? undefined : (
      fn.TAG === /* SyncOperation */0 ? fn._0 : panic$1(undefined)
    );
  struct.e = compiledSerializeOperation;
  return compiledSerializeOperation;
}

function isAsyncParse(struct) {
  var match = getParseOperation(struct);
  if (typeof match === "number" || match.TAG === /* SyncOperation */0) {
    return false;
  } else {
    return true;
  }
}

function raiseUnexpectedTypeError(input, struct) {
  var number = Js_types.classify(input);
  var tmp;
  if (typeof number === "number") {
    switch (number) {
      case /* JSFalse */0 :
      case /* JSTrue */1 :
          tmp = "Bool";
          break;
      case /* JSNull */2 :
          tmp = "Null";
          break;
      case /* JSUndefined */3 :
          tmp = "Option";
          break;
      
    }
  } else {
    switch (number.TAG | 0) {
      case /* JSNumber */0 :
          tmp = Number.isNaN(number._0) ? "NaN Literal (NaN)" : "Float";
          break;
      case /* JSString */1 :
          tmp = "String";
          break;
      case /* JSFunction */2 :
          tmp = "Function";
          break;
      case /* JSObject */3 :
          tmp = Array.isArray(number._0) ? "Array" : "Object";
          break;
      case /* JSSymbol */4 :
          tmp = "Symbol";
          break;
      case /* JSBigInt */5 :
          tmp = "BigInt";
          break;
      
    }
  }
  return raise$1({
              TAG: /* UnexpectedType */1,
              expected: struct.n,
              received: tmp
            });
}

function noOperation(input) {
  return input;
}

function initialSerialize(input) {
  var struct = this;
  var fn = getSerializeOperation(struct);
  var compiledSerialize = fn !== undefined ? fn : noOperation;
  struct.s = compiledSerialize;
  return compiledSerialize(input);
}

function intitialParse(input) {
  var struct = this;
  var fn = getParseOperation(struct);
  var compiledParse;
  compiledParse = typeof fn === "number" ? noOperation : (
      fn.TAG === /* SyncOperation */0 ? fn._0 : raise$1(/* UnexpectedAsync */2)
    );
  struct.p = compiledParse;
  return compiledParse(input);
}

function asyncNoopOperation(input) {
  return function () {
    return Promise.resolve(input);
  };
}

function intitialParseAsync(input) {
  var struct = this;
  var fn = getParseOperation(struct);
  var compiledParseAsync;
  if (typeof fn === "number") {
    compiledParseAsync = asyncNoopOperation;
  } else if (fn.TAG === /* SyncOperation */0) {
    var fn$1 = fn._0;
    compiledParseAsync = (function (input) {
        var syncValue = fn$1(input);
        return function () {
          return Promise.resolve(syncValue);
        };
      });
  } else {
    compiledParseAsync = fn._0;
  }
  struct.a = compiledParseAsync;
  return compiledParseAsync(input);
}

function parseWith(any, struct) {
  try {
    return {
            TAG: /* Ok */0,
            _0: struct.p(any)
          };
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toParseError(internalError._1)
            };
    }
    throw internalError;
  }
}

function parseOrRaiseWith(any, struct) {
  try {
    return struct.p(any);
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toParseError(internalError._1),
            Error: new Error()
          };
    }
    throw internalError;
  }
}

function asyncPrepareOk(value) {
  return {
          TAG: /* Ok */0,
          _0: value
        };
}

function asyncPrepareError(exn) {
  if (exn.RE_EXN_ID === Exception) {
    return {
            TAG: /* Error */1,
            _0: toParseError(exn._1)
          };
  }
  throw exn;
}

function parseAsyncWith(any, struct) {
  try {
    return struct.a(any)().then(asyncPrepareOk, asyncPrepareError);
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return Promise.resolve({
                  TAG: /* Error */1,
                  _0: toParseError(internalError._1)
                });
    }
    throw internalError;
  }
}

function parseAsyncInStepsWith(any, struct) {
  try {
    var asyncFn = struct.a(any);
    return {
            TAG: /* Ok */0,
            _0: (function () {
                return asyncFn().then(asyncPrepareOk, asyncPrepareError);
              })
          };
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toParseError(internalError._1)
            };
    }
    throw internalError;
  }
}

function serializeWith(value, struct) {
  try {
    return {
            TAG: /* Ok */0,
            _0: struct.s(value)
          };
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toSerializeError(internalError._1)
            };
    }
    throw internalError;
  }
}

function serializeOrRaiseWith(value, struct) {
  try {
    return struct.s(value);
  }
  catch (raw_internalError){
    var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
    if (internalError.RE_EXN_ID === Exception) {
      throw {
            RE_EXN_ID: Raised,
            _1: toSerializeError(internalError._1),
            Error: new Error()
          };
    }
    throw internalError;
  }
}

function recursive(fn) {
  var placeholder = {};
  var struct = fn(placeholder);
  Object.assign(placeholder, struct);
  if (isAsyncParse(placeholder)) {
    throw new Error("[rescript-struct] " + ("The \"" + struct.n + "\" struct in the S.recursive has an async parser. To make it work, use S.asyncRecursive instead.") + "");
  }
  return placeholder;
}

function asyncRecursive(fn) {
  var placeholder = {};
  var struct = fn(placeholder);
  Object.assign(placeholder, struct);
  placeholder.r = 1;
  return placeholder;
}

function make(namespace, name) {
  return "" + namespace + ":" + name + "";
}

var Id = {
  make: make
};

function get(struct, id) {
  var option = struct.m;
  if (option !== undefined) {
    return Js_dict.get(Caml_option.valFromOption(option), id);
  }
  
}

function set(struct, id, metadata) {
  var metadataChange = {};
  var maybeMetadataDict = Caml_option.some(Object.assign({}, struct.m, (metadataChange[id] = metadata, metadataChange)));
  return {
          n: struct.n,
          t: struct.t,
          pf: struct.pf,
          sf: struct.sf,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: maybeMetadataDict
        };
}

function refine(struct, maybeRefineParser, maybeRefineSerializer, param) {
  if (maybeRefineParser === undefined && maybeRefineSerializer === undefined) {
    panic("struct factory Refine");
  }
  var nextParseTransformationFactory = maybeRefineParser !== undefined ? (function (ctx, compilingStruct) {
        struct.pf(ctx, compilingStruct);
        planSyncTransformation(ctx, (function (input) {
                maybeRefineParser(input);
                return input;
              }));
      }) : struct.pf;
  return {
          n: struct.n,
          t: struct.t,
          pf: nextParseTransformationFactory,
          sf: maybeRefineSerializer !== undefined ? (function (ctx, compilingStruct) {
                planSyncTransformation(ctx, (function (input) {
                        maybeRefineSerializer(input);
                        return input;
                      }));
                struct.sf(ctx, compilingStruct);
              }) : struct.sf,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: nextParseTransformationFactory === struct.pf ? struct.i : undefined,
          m: struct.m
        };
}

function asyncRefine(struct, parser, param) {
  return {
          n: struct.n,
          t: struct.t,
          pf: (function (ctx, compilingStruct) {
              struct.pf(ctx, compilingStruct);
              planAsyncTransformation(ctx, (function (input) {
                      return parser(input).then(function (param) {
                                  return input;
                                });
                    }));
            }),
          sf: struct.sf,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: struct.m
        };
}

function transform(struct, maybeTransformParser, maybeTransformSerializer, param) {
  if (maybeTransformParser === undefined && maybeTransformSerializer === undefined) {
    panic("struct factory Transform");
  }
  return {
          n: struct.n,
          t: struct.t,
          pf: (function (ctx, compilingStruct) {
              struct.pf(ctx, compilingStruct);
              if (maybeTransformParser !== undefined) {
                return planSyncTransformation(ctx, maybeTransformParser);
              } else {
                return planSyncTransformation(ctx, (function (param) {
                              return raise$1(/* MissingParser */0);
                            }));
              }
            }),
          sf: (function (ctx, compilingStruct) {
              if (maybeTransformSerializer !== undefined) {
                planSyncTransformation(ctx, maybeTransformSerializer);
              } else {
                planSyncTransformation(ctx, (function (param) {
                        return raise$1(/* MissingSerializer */1);
                      }));
              }
              struct.sf(ctx, compilingStruct);
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: struct.m
        };
}

function advancedTransform(struct, maybeTransformParser, maybeTransformSerializer, param) {
  if (maybeTransformParser === undefined && maybeTransformSerializer === undefined) {
    panic("struct factory Transform");
  }
  return {
          n: struct.n,
          t: struct.t,
          pf: (function (ctx, compilingStruct) {
              struct.pf(ctx, compilingStruct);
              if (maybeTransformParser === undefined) {
                return planSyncTransformation(ctx, (function (param) {
                              return raise$1(/* MissingParser */0);
                            }));
              }
              var syncTransformation = maybeTransformParser(compilingStruct);
              if (syncTransformation.TAG === /* Sync */0) {
                return planSyncTransformation(ctx, syncTransformation._0);
              } else {
                return planAsyncTransformation(ctx, syncTransformation._0);
              }
            }),
          sf: (function (ctx, compilingStruct) {
              if (maybeTransformSerializer !== undefined) {
                var syncTransformation = maybeTransformSerializer(compilingStruct);
                if (syncTransformation.TAG === /* Sync */0) {
                  planSyncTransformation(ctx, syncTransformation._0);
                } else {
                  planAsyncTransformation(ctx, syncTransformation._0);
                }
              } else {
                planSyncTransformation(ctx, (function (param) {
                        return raise$1(/* MissingSerializer */1);
                      }));
              }
              struct.sf(ctx, compilingStruct);
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: struct.m
        };
}

function advancedPreprocess(struct, maybePreprocessParser, maybePreprocessSerializer, param) {
  if (maybePreprocessParser === undefined && maybePreprocessSerializer === undefined) {
    panic("struct factory Preprocess");
  }
  var unionStructs = struct.t;
  if (typeof unionStructs !== "number" && unionStructs.TAG === /* Union */6) {
    var tagged = {
      TAG: /* Union */6,
      _0: unionStructs._0.map(function (unionStruct) {
            return advancedPreprocess(unionStruct, maybePreprocessParser, maybePreprocessSerializer, undefined);
          })
    };
    return {
            n: struct.n,
            t: tagged,
            pf: struct.pf,
            sf: struct.sf,
            r: 0,
            e: 0,
            s: initialSerialize,
            p: intitialParse,
            a: intitialParseAsync,
            i: undefined,
            m: struct.m
          };
  }
  return {
          n: struct.n,
          t: struct.t,
          pf: (function (ctx, compilingStruct) {
              if (maybePreprocessParser !== undefined) {
                var syncTransformation = maybePreprocessParser(compilingStruct);
                if (syncTransformation.TAG === /* Sync */0) {
                  planSyncTransformation(ctx, syncTransformation._0);
                } else {
                  planAsyncTransformation(ctx, syncTransformation._0);
                }
              } else {
                planSyncTransformation(ctx, (function (param) {
                        return raise$1(/* MissingParser */0);
                      }));
              }
              struct.pf(ctx, compilingStruct);
            }),
          sf: (function (ctx, compilingStruct) {
              struct.sf(ctx, compilingStruct);
              if (maybePreprocessSerializer === undefined) {
                return planSyncTransformation(ctx, (function (param) {
                              return raise$1(/* MissingSerializer */1);
                            }));
              }
              var syncTransformation = maybePreprocessSerializer(compilingStruct);
              if (syncTransformation.TAG === /* Sync */0) {
                return planSyncTransformation(ctx, syncTransformation._0);
              } else {
                return planAsyncTransformation(ctx, syncTransformation._0);
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: struct.m
        };
}

function custom(name, maybeCustomParser, maybeCustomSerializer, param) {
  if (maybeCustomParser === undefined && maybeCustomSerializer === undefined) {
    panic("Custom struct factory");
  }
  return {
          n: name,
          t: /* Unknown */1,
          pf: (function (ctx, param) {
              if (maybeCustomParser !== undefined) {
                return planSyncTransformation(ctx, Caml_option.valFromOption(maybeCustomParser));
              } else {
                return planSyncTransformation(ctx, (function (param) {
                              return raise$1(/* MissingParser */0);
                            }));
              }
            }),
          sf: (function (ctx, param) {
              if (maybeCustomSerializer !== undefined) {
                return planSyncTransformation(ctx, Caml_option.valFromOption(maybeCustomSerializer));
              } else {
                return planSyncTransformation(ctx, (function (param) {
                              return raise$1(/* MissingSerializer */1);
                            }));
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

function factory(innerLiteral, variant) {
  var tagged = {
    TAG: /* Literal */0,
    _0: innerLiteral
  };
  var makeParseTransformationFactory = function (literalValue, test) {
    return function (ctx, struct) {
      planSyncTransformation(ctx, (function (input) {
              if (test(input)) {
                if (literalValue === input) {
                  return variant;
                } else {
                  return raise(literalValue, input, undefined, undefined);
                }
              } else {
                return raiseUnexpectedTypeError(input, struct);
              }
            }));
    };
  };
  var makeSerializeTransformationFactory = function (output) {
    return function (ctx, param) {
      planSyncTransformation(ctx, (function (input) {
              if (input === variant) {
                return output;
              } else {
                return raise(variant, input, undefined, undefined);
              }
            }));
    };
  };
  if (typeof innerLiteral === "number") {
    switch (innerLiteral) {
      case /* EmptyNull */0 :
          var serializeTransformationFactory = makeSerializeTransformationFactory(null);
          return {
                  n: "EmptyNull Literal (null)",
                  t: tagged,
                  pf: (function (ctx, struct) {
                      planSyncTransformation(ctx, (function (input) {
                              if (input === null) {
                                return variant;
                              } else {
                                return raiseUnexpectedTypeError(input, struct);
                              }
                            }));
                    }),
                  sf: serializeTransformationFactory,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  p: intitialParse,
                  a: intitialParseAsync,
                  i: undefined,
                  m: undefined
                };
      case /* EmptyOption */1 :
          var serializeTransformationFactory$1 = makeSerializeTransformationFactory(undefined);
          return {
                  n: "EmptyOption Literal (undefined)",
                  t: tagged,
                  pf: (function (ctx, struct) {
                      planSyncTransformation(ctx, (function (input) {
                              if (input === undefined) {
                                return variant;
                              } else {
                                return raiseUnexpectedTypeError(input, struct);
                              }
                            }));
                    }),
                  sf: serializeTransformationFactory$1,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  p: intitialParse,
                  a: intitialParseAsync,
                  i: undefined,
                  m: undefined
                };
      case /* NaN */2 :
          var serializeTransformationFactory$2 = makeSerializeTransformationFactory(NaN);
          return {
                  n: "NaN Literal (NaN)",
                  t: tagged,
                  pf: (function (ctx, struct) {
                      planSyncTransformation(ctx, (function (input) {
                              if (Number.isNaN(input)) {
                                return variant;
                              } else {
                                return raiseUnexpectedTypeError(input, struct);
                              }
                            }));
                    }),
                  sf: serializeTransformationFactory$2,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  p: intitialParse,
                  a: intitialParseAsync,
                  i: undefined,
                  m: undefined
                };
      
    }
  } else {
    switch (innerLiteral.TAG | 0) {
      case /* String */0 :
          var string = innerLiteral._0;
          var serializeTransformationFactory$3 = makeSerializeTransformationFactory(string);
          var parseTransformationFactory = makeParseTransformationFactory(string, (function (input) {
                  return typeof input === "string";
                }));
          return {
                  n: "String Literal (\"" + string + "\")",
                  t: tagged,
                  pf: parseTransformationFactory,
                  sf: serializeTransformationFactory$3,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  p: intitialParse,
                  a: intitialParseAsync,
                  i: undefined,
                  m: undefined
                };
      case /* Int */1 :
          var $$int = innerLiteral._0;
          var serializeTransformationFactory$4 = makeSerializeTransformationFactory($$int);
          var parseTransformationFactory$1 = makeParseTransformationFactory($$int, (function (input) {
                  if (typeof input === "number" && input < 2147483648 && input > -2147483649) {
                    return input % 1 === 0;
                  } else {
                    return false;
                  }
                }));
          var name = "Int Literal (" + $$int.toString() + ")";
          return {
                  n: name,
                  t: tagged,
                  pf: parseTransformationFactory$1,
                  sf: serializeTransformationFactory$4,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  p: intitialParse,
                  a: intitialParseAsync,
                  i: undefined,
                  m: undefined
                };
      case /* Float */2 :
          var $$float = innerLiteral._0;
          var serializeTransformationFactory$5 = makeSerializeTransformationFactory($$float);
          var parseTransformationFactory$2 = makeParseTransformationFactory($$float, (function (input) {
                  return typeof input === "number";
                }));
          var name$1 = "Float Literal (" + $$float.toString() + ")";
          return {
                  n: name$1,
                  t: tagged,
                  pf: parseTransformationFactory$2,
                  sf: serializeTransformationFactory$5,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  p: intitialParse,
                  a: intitialParseAsync,
                  i: undefined,
                  m: undefined
                };
      case /* Bool */3 :
          var bool = innerLiteral._0;
          var serializeTransformationFactory$6 = makeSerializeTransformationFactory(bool);
          var parseTransformationFactory$3 = makeParseTransformationFactory(bool, (function (input) {
                  return typeof input === "boolean";
                }));
          var name$2 = "Bool Literal (" + bool.toString() + ")";
          return {
                  n: name$2,
                  t: tagged,
                  pf: parseTransformationFactory$3,
                  sf: serializeTransformationFactory$6,
                  r: 0,
                  e: 0,
                  s: initialSerialize,
                  p: intitialParse,
                  a: intitialParseAsync,
                  i: undefined,
                  m: undefined
                };
      
    }
  }
}

function factory$1(innerLiteral) {
  if (typeof innerLiteral === "number") {
    return factory(innerLiteral, undefined);
  } else {
    return factory(innerLiteral, innerLiteral._0);
  }
}

var metadataId = "rescript-struct:Object_UnknownKeys";

function classify$1(struct) {
  var option = get(struct, metadataId);
  if (option !== undefined) {
    return Caml_option.valFromOption(option);
  } else {
    return /* Strip */1;
  }
}

var value = Symbol("rescript-struct:Object.FieldDefinition");

function analyzeDefinition(definition, definerCtx, path, inlinedPath) {
  if (definition === value) {
    var originalFieldName = definerCtx.originalFieldNames[definerCtx.registeredFieldsCount];
    definerCtx.registeredFieldsCount = definerCtx.registeredFieldsCount + 1;
    definerCtx.definedFieldInstructions.push({
          TAG: /* Registered */1,
          fieldStruct: definerCtx.originalFields[originalFieldName],
          originalFieldName: originalFieldName,
          inlinedOriginalFieldName: JSON.stringify(originalFieldName),
          inlinedPath: inlinedPath,
          path: path
        });
    return ;
  }
  if (typeof definition === "object" && definition !== null) {
    definerCtx.inlinedPreparationPathes.push(inlinedPath);
    definerCtx.inlinedPreparationValues.push(Array.isArray(definition) ? "[]" : "{}");
    var definitionFieldNames = Object.keys(definition);
    for(var idx = 0 ,idx_finish = definitionFieldNames.length; idx < idx_finish; ++idx){
      var definitionFieldName = definitionFieldNames[idx];
      var fieldDefinition = definition[definitionFieldName];
      var tmp = path === "" ? definitionFieldName : "" + path + "," + definitionFieldName + "";
      analyzeDefinition(fieldDefinition, definerCtx, tmp, "" + inlinedPath + "[" + JSON.stringify(definitionFieldName) + "]");
    }
    return ;
  }
  definerCtx.constantInstructions.push({
        inlinedPath: inlinedPath,
        v: definition,
        path: path
      });
}

function structToInlinedValue(_struct) {
  while(true) {
    var struct = _struct;
    var unionStructs = struct.t;
    if (typeof unionStructs === "number") {
      throw undefined;
    }
    switch (unionStructs.TAG | 0) {
      case /* Literal */0 :
          var string = unionStructs._0;
          if (typeof string !== "number") {
            if (string.TAG === /* String */0) {
              return JSON.stringify(string._0);
            } else {
              return string._0.toString();
            }
          }
          switch (string) {
            case /* EmptyNull */0 :
                return "null";
            case /* EmptyOption */1 :
                return "undefined";
            case /* NaN */2 :
                return "NaN";
            
          }
      case /* Object */4 :
          var fields = unionStructs.fields;
          return "{" + unionStructs.fieldNames.map((function(fields){
                      return function (fieldName) {
                        return "" + JSON.stringify(fieldName) + ":" + structToInlinedValue(fields[fieldName]) + "";
                      }
                      }(fields))).join(",") + "}";
      case /* Tuple */5 :
          return "[" + unionStructs._0.map(structToInlinedValue).join(",") + "]";
      case /* Union */6 :
          _struct = unionStructs._0[0];
          continue ;
      default:
        throw undefined;
    }
  };
}

function factory$2(definer) {
  var definerCtx = {
    originalFieldNames: undefined,
    originalFields: {},
    registeredFieldsCount: 0,
    inlinedPreparationPathes: [],
    inlinedPreparationValues: [],
    definedFieldInstructions: [],
    constantInstructions: []
  };
  var definition = definer(definerCtx);
  var originalFieldNames = Object.keys(definerCtx.originalFields);
  definerCtx.originalFieldNames = originalFieldNames;
  analyzeDefinition(definition, definerCtx, "", "");
  var originalFieldNamesCount = originalFieldNames.length;
  if (definerCtx.registeredFieldsCount > originalFieldNamesCount) {
    throw new Error("[rescript-struct] The object defention has more registered fields than expected.");
  }
  if (definerCtx.registeredFieldsCount < originalFieldNamesCount) {
    throw new Error("[rescript-struct] The object defention contains fields that weren't registered.");
  }
  var serializeTransformationFactory = function (ctx, param) {
    var inliningOriginalFieldNameRef = undefined;
    try {
      var constantInstructions = definerCtx.constantInstructions;
      var definedFieldInstructions = definerCtx.definedFieldInstructions;
      var serializeFnsByInstructionIdx = {};
      var stringRef = "";
      for(var idx = 0 ,idx_finish = constantInstructions.length; idx < idx_finish; ++idx){
        var match = constantInstructions[idx];
        var inlinedPath = match.inlinedPath;
        var content = "r(" + idx.toString() + ",t" + inlinedPath + ")";
        var condition = "t" + inlinedPath + "!==d[" + idx.toString() + "].v";
        stringRef = stringRef + ("if(" + condition + "){" + content + "}");
      }
      var constants = stringRef;
      var contentRef = "var i;return{";
      for(var idx$1 = 0 ,idx_finish$1 = definedFieldInstructions.length; idx$1 < idx_finish$1; ++idx$1){
        var definedFieldInstruction = definedFieldInstructions[idx$1];
        var fieldStruct = definedFieldInstruction.fieldStruct;
        var inlinedOriginalFieldName;
        inlinedOriginalFieldName = definedFieldInstruction.TAG === /* Discriminant */0 ? definedFieldInstruction.inlinedOriginalFieldName : definedFieldInstruction.inlinedOriginalFieldName;
        var inlinedInstructionIdx = idx$1.toString();
        var tmp;
        if (definedFieldInstruction.TAG === /* Discriminant */0) {
          var tmp$1;
          tmp$1 = definedFieldInstruction.TAG === /* Discriminant */0 ? definedFieldInstruction.originalFieldName : definedFieldInstruction.originalFieldName;
          inliningOriginalFieldNameRef = tmp$1;
          tmp = "" + inlinedOriginalFieldName + ":" + structToInlinedValue(fieldStruct) + ",";
        } else {
          var inlinedPath$1 = definedFieldInstruction.inlinedPath;
          var fn = getSerializeOperation(fieldStruct);
          if (fn !== undefined) {
            serializeFnsByInstructionIdx[inlinedInstructionIdx] = fn;
            tmp = "" + inlinedOriginalFieldName + ":(i=" + inlinedInstructionIdx + ",s[" + inlinedInstructionIdx + "](t" + inlinedPath$1 + ")),";
          } else {
            tmp = "" + inlinedOriginalFieldName + ":t" + inlinedPath$1 + ",";
          }
        }
        contentRef = contentRef + tmp;
      }
      var tryContent = contentRef + "}";
      var originalObjectConstructionAndReturn = "try{" + tryContent + "}catch(e){c(e,i)}";
      var inlinedSerializeFunction = "function(t){" + ("" + constants + "" + originalObjectConstructionAndReturn + "") + "}";
      planSyncTransformation(ctx, new Function("s", "d", "r", "c", "return " + inlinedSerializeFunction + "")(serializeFnsByInstructionIdx, constantInstructions, (function (instructionIdx, received) {
                  var match = constantInstructions[instructionIdx];
                  return raise(match.v, received, match.path, undefined);
                }), (function (exn, instructionIdx) {
                  var tmp;
                  if (exn.RE_EXN_ID === Exception) {
                    var definedFieldInstruction = definedFieldInstructions[instructionIdx];
                    tmp = definedFieldInstruction.TAG === /* Discriminant */0 ? panic$1(undefined) : ({
                          RE_EXN_ID: Exception,
                          _1: prependLocation(exn._1, definedFieldInstruction.path)
                        });
                  } else {
                    tmp = exn;
                  }
                  throw tmp;
                })));
    }
    catch (exn){
      var inliningOriginalFieldName = inliningOriginalFieldNameRef;
      planSyncTransformation(ctx, (function (param) {
              throw {
                    RE_EXN_ID: Exception,
                    _1: {
                      c: /* MissingSerializer */1,
                      p: inliningOriginalFieldName
                    },
                    Error: new Error()
                  };
            }));
    }
  };
  var parseTransformationFactory = function (ctx, struct) {
    var constantInstructions = definerCtx.constantInstructions;
    var definedFieldInstructions = definerCtx.definedFieldInstructions;
    var inlinedPreparationValues = definerCtx.inlinedPreparationValues;
    var inlinedPreparationPathes = definerCtx.inlinedPreparationPathes;
    var withUnknownKeysRefinement = classify$1(struct) === /* Strict */0;
    var definedAsyncFieldInstructions = [];
    var parseFnsByInstructionIdx = {};
    var refinement = "if(!(typeof o===\"object\"&&o!==null&&!Array.isArray(o))){u(o)}";
    var stringRef = "var t;";
    for(var idx = 0 ,idx_finish = inlinedPreparationPathes.length; idx < idx_finish; ++idx){
      var preparationPath = inlinedPreparationPathes[idx];
      var preparationInlinedValue = inlinedPreparationValues[idx];
      stringRef = stringRef + ("t" + preparationPath + "=" + preparationInlinedValue + ";");
    }
    var preparation = stringRef;
    var transformedObjectConstruction;
    if (definedFieldInstructions.length === 0) {
      transformedObjectConstruction = "";
    } else {
      var stringRef$1 = "";
      for(var idx$1 = 0 ,idx_finish$1 = definedFieldInstructions.length; idx$1 < idx_finish$1; ++idx$1){
        var definedFieldInstruction = definedFieldInstructions[idx$1];
        var fieldStruct = definedFieldInstruction.fieldStruct;
        var inlinedOriginalFieldName;
        inlinedOriginalFieldName = definedFieldInstruction.TAG === /* Discriminant */0 ? definedFieldInstruction.inlinedOriginalFieldName : definedFieldInstruction.inlinedOriginalFieldName;
        var inlinedInstructionIdx = idx$1.toString();
        var parseOperation = getParseOperation(fieldStruct);
        var maybeParseFn;
        maybeParseFn = typeof parseOperation === "number" ? undefined : parseOperation._0;
        var isAsync;
        isAsync = typeof parseOperation === "number" || parseOperation.TAG === /* SyncOperation */0 ? false : true;
        var inlinedInputData = "o[" + inlinedOriginalFieldName + "]";
        var maybeInlinedDestination;
        if (isAsync) {
          var inlinedDestination = "a[" + definedAsyncFieldInstructions.length.toString() + "]";
          if (definedAsyncFieldInstructions.length === 0) {
            stringRef$1 = stringRef$1 + "var a={};";
          }
          if (definedFieldInstruction.TAG !== /* Discriminant */0) {
            stringRef$1 = stringRef$1 + ("t" + definedFieldInstruction.inlinedPath + "=undefined;");
          }
          definedAsyncFieldInstructions.push(definedFieldInstruction);
          maybeInlinedDestination = inlinedDestination;
        } else {
          maybeInlinedDestination = definedFieldInstruction.TAG === /* Discriminant */0 ? undefined : "t" + definedFieldInstruction.inlinedPath + "";
        }
        var match = fieldStruct.i;
        stringRef$1 = stringRef$1 + (
          maybeParseFn !== undefined ? (
              match !== undefined ? "var v=" + inlinedInputData + ";if(" + match + "){" + (
                  maybeInlinedDestination !== undefined ? "" + maybeInlinedDestination + "=v" : ""
                ) + "}else{i=" + inlinedInstructionIdx + ";s(v,f[" + inlinedOriginalFieldName + "])}" : (parseFnsByInstructionIdx[inlinedInstructionIdx] = maybeParseFn, "i=" + inlinedInstructionIdx + ";" + (
                    maybeInlinedDestination !== undefined ? "" + maybeInlinedDestination + "=" : ""
                  ) + "p[" + inlinedInstructionIdx + "](" + inlinedInputData + ");")
            ) : (
              maybeInlinedDestination !== undefined ? "" + maybeInlinedDestination + "=" + inlinedInputData + ";" : ""
            )
        );
      }
      var tryContent = stringRef$1;
      transformedObjectConstruction = "var i;" + ("try{" + tryContent + "}catch(e){c(e,i)}");
    }
    var unknownKeysRefinement;
    if (withUnknownKeysRefinement) {
      var stringRef$2 = "for(var k in o){switch(k){";
      for(var idx$2 = 0 ,idx_finish$2 = definedFieldInstructions.length; idx$2 < idx_finish$2; ++idx$2){
        var definedFieldInstruction$1 = definedFieldInstructions[idx$2];
        var inlinedOriginalFieldName$1;
        inlinedOriginalFieldName$1 = definedFieldInstruction$1.TAG === /* Discriminant */0 ? definedFieldInstruction$1.inlinedOriginalFieldName : definedFieldInstruction$1.inlinedOriginalFieldName;
        stringRef$2 = stringRef$2 + ("case" + inlinedOriginalFieldName$1 + ":continue;");
      }
      unknownKeysRefinement = stringRef$2 + "default:x(k)}}";
    } else {
      unknownKeysRefinement = "";
    }
    var stringRef$3 = "";
    for(var idx$3 = 0 ,idx_finish$3 = constantInstructions.length; idx$3 < idx_finish$3; ++idx$3){
      var match$1 = constantInstructions[idx$3];
      stringRef$3 = stringRef$3 + ("t" + match$1.inlinedPath + "=d[" + idx$3.toString() + "].v;");
    }
    var constants = stringRef$3;
    var returnValue = definedAsyncFieldInstructions.length === 0 ? "t" : "a.t=t,a";
    var inlinedParseFunction = "function(o){" + ("" + refinement + "" + preparation + "" + transformedObjectConstruction + "" + unknownKeysRefinement + "" + constants + "return " + returnValue + "") + "}";
    planSyncTransformation(ctx, new Function("c", "p", "f", "d", "u", "s", "x", "return " + inlinedParseFunction + "")((function (exn, instructionIdx) {
                var tmp;
                if (exn.RE_EXN_ID === Exception) {
                  var definedFieldInstruction = definedFieldInstructions[instructionIdx];
                  var tmp$1;
                  tmp$1 = definedFieldInstruction.TAG === /* Discriminant */0 ? definedFieldInstruction.originalFieldName : definedFieldInstruction.originalFieldName;
                  tmp = {
                    RE_EXN_ID: Exception,
                    _1: prependLocation(exn._1, tmp$1)
                  };
                } else {
                  tmp = exn;
                }
                throw tmp;
              }), parseFnsByInstructionIdx, definerCtx.originalFields, constantInstructions, (function (input) {
                return raiseUnexpectedTypeError(input, struct);
              }), raiseUnexpectedTypeError, (function (exccessFieldName) {
                return raise$1({
                            TAG: /* ExcessField */4,
                            _0: exccessFieldName
                          });
              })));
    if (definedAsyncFieldInstructions.length <= 0) {
      return ;
    }
    var resolveVar = "rs";
    var rejectVar = "rj";
    var contentRef = "var y=" + definedAsyncFieldInstructions.length.toString() + ",t=a.t;";
    for(var idx$4 = 0 ,idx_finish$4 = definedAsyncFieldInstructions.length; idx$4 < idx_finish$4; ++idx$4){
      var definedAsyncFieldInstruction = definedAsyncFieldInstructions[idx$4];
      var inlinedIdx = idx$4.toString();
      var fieldValueVar = "z";
      var inlinedFieldValueAssignment;
      inlinedFieldValueAssignment = definedAsyncFieldInstruction.TAG === /* Discriminant */0 ? "" : "t" + definedAsyncFieldInstruction.inlinedPath + "=" + fieldValueVar + "";
      var inlinedIteration = "if(y--===1){" + ("" + resolveVar + "(t)") + "}";
      var onFieldSuccessInlinedFnContent = "" + inlinedFieldValueAssignment + ";" + inlinedIteration + "";
      var onFieldSuccessInlinedFn = "function(" + fieldValueVar + "){" + onFieldSuccessInlinedFnContent + "}";
      var errorVar = "z";
      var onFieldErrorInlinedFn = "function(" + errorVar + "){" + ("" + rejectVar + "(j(" + errorVar + "," + inlinedIdx + "))") + "}";
      contentRef = contentRef + ("a[" + inlinedIdx + "]().then(" + onFieldSuccessInlinedFn + "," + onFieldErrorInlinedFn + ");");
    }
    var content = contentRef;
    var inlinedAsyncParseFunction = "function(a){" + ("return " + ("new Promise(function(" + resolveVar + "," + rejectVar + "){" + content + "})") + "") + "}";
    planAsyncTransformation(ctx, new Function("j", "return " + inlinedAsyncParseFunction + "")(function (exn, asyncInstructionIdx) {
              if (exn.RE_EXN_ID !== Exception) {
                return exn;
              }
              var definedFieldInstruction = definedAsyncFieldInstructions[asyncInstructionIdx];
              var tmp;
              tmp = definedFieldInstruction.TAG === /* Discriminant */0 ? definedFieldInstruction.originalFieldName : definedFieldInstruction.originalFieldName;
              return {
                      RE_EXN_ID: Exception,
                      _1: prependLocation(exn._1, tmp)
                    };
            }));
  };
  return {
          n: "Object",
          t: {
            TAG: /* Object */4,
            fields: definerCtx.originalFields,
            fieldNames: definerCtx.originalFieldNames
          },
          pf: parseTransformationFactory,
          sf: serializeTransformationFactory,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

function field(definerCtx, originalFieldName, struct) {
  definerCtx.originalFields[originalFieldName] = struct;
  return value;
}

function discriminant(definerCtx, originalFieldName, struct) {
  definerCtx.originalFields[originalFieldName] = struct;
  definerCtx.registeredFieldsCount = definerCtx.registeredFieldsCount + 1;
  definerCtx.definedFieldInstructions.unshift({
        TAG: /* Discriminant */0,
        fieldStruct: struct,
        inlinedOriginalFieldName: JSON.stringify(originalFieldName),
        originalFieldName: originalFieldName
      });
}

function strip(struct) {
  return set(struct, metadataId, /* Strip */1);
}

function strict(struct) {
  return set(struct, metadataId, /* Strict */0);
}

function factory$3(param) {
  var transformationFactory = function (ctx, struct) {
    planSyncTransformation(ctx, (function (input) {
            return raiseUnexpectedTypeError(input, struct);
          }));
  };
  return {
          n: "Never",
          t: /* Never */0,
          pf: transformationFactory,
          sf: transformationFactory,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: "false",
          m: undefined
        };
}

function factory$4(param) {
  return {
          n: "Unknown",
          t: /* Unknown */1,
          pf: empty,
          sf: empty,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

var cuidRegex = /^c[^\s-]{8,}$/i;

var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;

var emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;

function factory$5(param) {
  return {
          n: "String",
          t: /* String */2,
          pf: (function (ctx, struct) {
              planSyncTransformation(ctx, (function (input) {
                      if (typeof input === "string") {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    }));
            }),
          sf: empty,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: "typeof v===\"string\"",
          m: undefined
        };
}

function min(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length >= length) {
      return ;
    }
    var $$default = "String must be " + length.toString() + " or more characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length <= length) {
      return ;
    }
    var $$default = "String must be " + length.toString() + " or fewer characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function length(struct, maybeMessage, length$1) {
  var refiner = function (value) {
    if (value.length === length$1) {
      return ;
    }
    var $$default = "String must be exactly " + length$1.toString() + " characters long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function email(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid email address";
  var refiner = function (value) {
    if (!emailRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function uuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid UUID";
  var refiner = function (value) {
    if (!uuidRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function cuid(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid CUID";
  var refiner = function (value) {
    if (!cuidRegex.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function url(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid url";
  var refiner = function (value) {
    var tmp;
    try {
      new URL(value);
      tmp = true;
    }
    catch (exn){
      tmp = false;
    }
    if (!tmp) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function pattern(struct, messageOpt, re) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid";
  var refiner = function (value) {
    re.lastIndex = 0;
    if (!re.test(value)) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function trimmed(struct, param) {
  var transformer = function (prim) {
    return prim.trim();
  };
  return transform(struct, transformer, transformer, undefined);
}

function factory$6(innerStruct) {
  return {
          n: "Json",
          t: /* String */2,
          pf: (function (ctx, struct) {
              var fn = getParseOperation(innerStruct);
              var $$process = typeof fn === "number" ? (function (prim) {
                    return prim;
                  }) : fn._0;
              planSyncTransformation(ctx, (function (input) {
                      if (typeof input !== "string") {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                      var __x;
                      try {
                        __x = JSON.parse(input);
                      }
                      catch (raw_obj){
                        var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
                        if (obj.RE_EXN_ID === Js_exn.$$Error) {
                          var option = obj._1.message;
                          __x = raise$2(option !== undefined ? Caml_option.valFromOption(option) : "Failed to parse JSON");
                        } else {
                          throw obj;
                        }
                      }
                      return $$process(__x);
                    }));
              var match = getParseOperation(innerStruct);
              if (typeof match === "number" || match.TAG === /* SyncOperation */0) {
                return ;
              } else {
                return planAsyncTransformation(ctx, (function (asyncFn) {
                              return asyncFn();
                            }));
              }
            }),
          sf: (function (ctx, param) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              return JSON.stringify(fn(input));
                            }));
              } else {
                return planSyncTransformation(ctx, (function (input) {
                              return JSON.stringify(input);
                            }));
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

function factory$7(param) {
  return {
          n: "Bool",
          t: /* Bool */5,
          pf: (function (ctx, struct) {
              planSyncTransformation(ctx, (function (input) {
                      if (typeof input === "boolean") {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    }));
            }),
          sf: empty,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: "typeof v===\"boolean\"",
          m: undefined
        };
}

function factory$8(param) {
  return {
          n: "Int",
          t: /* Int */3,
          pf: (function (ctx, struct) {
              planSyncTransformation(ctx, (function (input) {
                      if (typeof input === "number" && input < 2147483648 && input > -2147483649 && input % 1 === 0) {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    }));
            }),
          sf: empty,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: "typeof v===\"number\"&&v<2147483648&&v>-2147483649&&v%1===0",
          m: undefined
        };
}

function min$1(struct, maybeMessage, thanValue) {
  var refiner = function (value) {
    if (value >= thanValue) {
      return ;
    }
    var $$default = "Number must be greater than or equal to " + thanValue.toString() + "";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max$1(struct, maybeMessage, thanValue) {
  var refiner = function (value) {
    if (value <= thanValue) {
      return ;
    }
    var $$default = "Number must be lower than or equal to " + thanValue.toString() + "";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function port(struct, messageOpt, param) {
  var message = messageOpt !== undefined ? messageOpt : "Invalid port";
  var refiner = function (value) {
    if (value < 1 || value > 65535) {
      return raise$2(message);
    }
    
  };
  return refine(struct, refiner, refiner, undefined);
}

function factory$9(param) {
  return {
          n: "Float",
          t: /* Float */4,
          pf: (function (ctx, struct) {
              planSyncTransformation(ctx, (function (input) {
                      if (typeof input === "number" && !Number.isNaN(input)) {
                        return input;
                      } else {
                        return raiseUnexpectedTypeError(input, struct);
                      }
                    }));
            }),
          sf: empty,
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: "typeof v===\"number\"&&!Number.isNaN(v)",
          m: undefined
        };
}

function factory$10(innerStruct) {
  return {
          n: "Null",
          t: {
            TAG: /* Null */2,
            _0: innerStruct
          },
          pf: (function (ctx, param) {
              var planSyncTransformation$1 = function (fn) {
                planSyncTransformation(ctx, (function (input) {
                        if (input !== null) {
                          return Caml_option.some(fn(input));
                        }
                        
                      }));
              };
              var fn = getParseOperation(innerStruct);
              if (typeof fn === "number") {
                return planSyncTransformation(ctx, (function (prim) {
                              if (prim === null) {
                                return ;
                              } else {
                                return Caml_option.some(prim);
                              }
                            }));
              }
              if (fn.TAG === /* SyncOperation */0) {
                return planSyncTransformation$1(fn._0);
              }
              planSyncTransformation$1(fn._0);
              planAsyncTransformation(ctx, (function (input) {
                      if (input !== undefined) {
                        return input().then(function (value) {
                                    return Caml_option.some(value);
                                  });
                      } else {
                        return Promise.resolve(undefined);
                      }
                    }));
            }),
          sf: (function (ctx, param) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              if (input !== undefined) {
                                return fn(Caml_option.valFromOption(input));
                              } else {
                                return null;
                              }
                            }));
              } else {
                return planSyncTransformation(ctx, (function (input) {
                              if (input !== undefined) {
                                return Caml_option.valFromOption(input);
                              } else {
                                return null;
                              }
                            }));
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

function factory$11(innerStruct) {
  return {
          n: "Option",
          t: {
            TAG: /* Option */1,
            _0: innerStruct
          },
          pf: (function (ctx, param) {
              var planSyncTransformation$1 = function (fn) {
                planSyncTransformation(ctx, (function (input) {
                        if (input !== undefined) {
                          return Caml_option.some(fn(Caml_option.valFromOption(input)));
                        }
                        
                      }));
              };
              var fn = getParseOperation(innerStruct);
              if (typeof fn === "number") {
                return ;
              }
              if (fn.TAG === /* SyncOperation */0) {
                return planSyncTransformation$1(fn._0);
              }
              planSyncTransformation$1(fn._0);
              planAsyncTransformation(ctx, (function (input) {
                      if (input !== undefined) {
                        return input().then(function (value) {
                                    return Caml_option.some(value);
                                  });
                      } else {
                        return Promise.resolve(undefined);
                      }
                    }));
            }),
          sf: (function (ctx, param) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              if (input !== undefined) {
                                return fn(Caml_option.valFromOption(input));
                              }
                              
                            }));
              } else {
                return planSyncTransformation(ctx, (function (input) {
                              if (input !== undefined) {
                                return Caml_option.valFromOption(input);
                              }
                              
                            }));
              }
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

var metadataId$1 = "rescript-struct:Deprecated";

function factory$12(innerStruct, maybeMessage, param) {
  return set(factory$11(innerStruct), metadataId$1, maybeMessage !== undefined ? /* WithMessage */({
                  _0: maybeMessage
                }) : /* WithoutMessage */0);
}

function classify$2(struct) {
  return get(struct, metadataId$1);
}

function factory$13(innerStruct) {
  return {
          n: "Array",
          t: {
            TAG: /* Array */3,
            _0: innerStruct
          },
          pf: (function (ctx, struct) {
              planSyncTransformation(ctx, (function (input) {
                      if (Array.isArray(input) === false) {
                        return raiseUnexpectedTypeError(input, struct);
                      } else {
                        return input;
                      }
                    }));
              var planSyncTransformation$1 = function (fn) {
                planSyncTransformation(ctx, (function (input) {
                        var newArray = [];
                        for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                          var innerData = input[idx];
                          try {
                            var value = fn(innerData);
                            newArray.push(value);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, idx.toString()),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        return newArray;
                      }));
              };
              var fn = getParseOperation(innerStruct);
              if (typeof fn === "number") {
                return ;
              }
              if (fn.TAG === /* SyncOperation */0) {
                return planSyncTransformation$1(fn._0);
              }
              planSyncTransformation$1(fn._0);
              planAsyncTransformation(ctx, (function (input) {
                      return Promise.all(input.map(function (asyncFn, idx) {
                                      return asyncFn().catch(function (exn) {
                                                  throw exn.RE_EXN_ID === Exception ? ({
                                                            RE_EXN_ID: Exception,
                                                            _1: prependLocation(exn._1, idx.toString())
                                                          }) : exn;
                                                });
                                    }));
                    }));
            }),
          sf: (function (ctx, param) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              var newArray = [];
                              for(var idx = 0 ,idx_finish = input.length; idx < idx_finish; ++idx){
                                var innerData = input[idx];
                                try {
                                  var value = fn(innerData);
                                  newArray.push(value);
                                }
                                catch (raw_internalError){
                                  var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                  if (internalError.RE_EXN_ID === Exception) {
                                    throw {
                                          RE_EXN_ID: Exception,
                                          _1: prependLocation(internalError._1, idx.toString()),
                                          Error: new Error()
                                        };
                                  }
                                  throw internalError;
                                }
                              }
                              return newArray;
                            }));
              }
              
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

function min$2(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length >= length) {
      return ;
    }
    var $$default = "Array must be " + length.toString() + " or more items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function max$2(struct, maybeMessage, length) {
  var refiner = function (value) {
    if (value.length <= length) {
      return ;
    }
    var $$default = "Array must be " + length.toString() + " or fewer items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function length$1(struct, maybeMessage, length$2) {
  var refiner = function (value) {
    if (value.length === length$2) {
      return ;
    }
    var $$default = "Array must be exactly " + length$2.toString() + " items long";
    raise$2(maybeMessage !== undefined ? Caml_option.valFromOption(maybeMessage) : $$default);
  };
  return refine(struct, refiner, refiner, undefined);
}

function factory$14(innerStruct) {
  return {
          n: "Dict",
          t: {
            TAG: /* Dict */7,
            _0: innerStruct
          },
          pf: (function (ctx, struct) {
              var planSyncTransformation$1 = function (fn) {
                planSyncTransformation(ctx, (function (input) {
                        var newDict = {};
                        var keys = Object.keys(input);
                        for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                          var key = keys[idx];
                          var innerData = input[key];
                          try {
                            var value = fn(innerData);
                            newDict[key] = value;
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, key),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        }
                        return newDict;
                      }));
              };
              planSyncTransformation(ctx, (function (input) {
                      if ((typeof input === "object" && input !== null && !Array.isArray(input)) === false) {
                        return raiseUnexpectedTypeError(input, struct);
                      } else {
                        return input;
                      }
                    }));
              var fn = getParseOperation(innerStruct);
              if (typeof fn === "number") {
                return ;
              }
              if (fn.TAG === /* SyncOperation */0) {
                return planSyncTransformation$1(fn._0);
              }
              planSyncTransformation$1(fn._0);
              planAsyncTransformation(ctx, (function (input) {
                      var keys = Object.keys(input);
                      return Promise.all(keys.map(function (key) {
                                        var asyncFn = input[key];
                                        try {
                                          return asyncFn().catch(function (exn) {
                                                      throw exn.RE_EXN_ID === Exception ? ({
                                                                RE_EXN_ID: Exception,
                                                                _1: prependLocation(exn._1, key)
                                                              }) : exn;
                                                    });
                                        }
                                        catch (raw_internalError){
                                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                          if (internalError.RE_EXN_ID === Exception) {
                                            throw {
                                                  RE_EXN_ID: Exception,
                                                  _1: prependLocation(internalError._1, key),
                                                  Error: new Error()
                                                };
                                          }
                                          throw internalError;
                                        }
                                      })).then(function (values) {
                                  var tempDict = {};
                                  values.forEach(function (value, idx) {
                                        var key = keys[idx];
                                        tempDict[key] = value;
                                      });
                                  return tempDict;
                                });
                    }));
            }),
          sf: (function (ctx, param) {
              var fn = getSerializeOperation(innerStruct);
              if (fn !== undefined) {
                return planSyncTransformation(ctx, (function (input) {
                              var newDict = {};
                              var keys = Object.keys(input);
                              for(var idx = 0 ,idx_finish = keys.length; idx < idx_finish; ++idx){
                                var key = keys[idx];
                                var innerData = input[key];
                                try {
                                  var value = fn(innerData);
                                  newDict[key] = value;
                                }
                                catch (raw_internalError){
                                  var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                  if (internalError.RE_EXN_ID === Exception) {
                                    throw {
                                          RE_EXN_ID: Exception,
                                          _1: prependLocation(internalError._1, key),
                                          Error: new Error()
                                        };
                                  }
                                  throw internalError;
                                }
                              }
                              return newDict;
                            }));
              }
              
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

var metadataId$2 = "rescript-struct:Defaulted";

function factory$15(innerStruct, defaultValue) {
  return set({
              n: innerStruct.n,
              t: innerStruct.t,
              pf: (function (ctx, param) {
                  var fn = getParseOperation(innerStruct);
                  if (typeof fn === "number") {
                    return planSyncTransformation(ctx, (function (input) {
                                  if (input !== undefined) {
                                    return Caml_option.valFromOption(input);
                                  } else {
                                    return defaultValue;
                                  }
                                }));
                  }
                  if (fn.TAG === /* SyncOperation */0) {
                    var fn$1 = fn._0;
                    return planSyncTransformation(ctx, (function (input) {
                                  var option = fn$1(input);
                                  if (option !== undefined) {
                                    return Caml_option.valFromOption(option);
                                  } else {
                                    return defaultValue;
                                  }
                                }));
                  }
                  planSyncTransformation(ctx, fn._0);
                  planAsyncTransformation(ctx, (function (asyncFn) {
                          return asyncFn().then(function (value) {
                                      if (value !== undefined) {
                                        return Caml_option.valFromOption(value);
                                      } else {
                                        return defaultValue;
                                      }
                                    });
                        }));
                }),
              sf: (function (ctx, param) {
                  var fn = getSerializeOperation(innerStruct);
                  if (fn !== undefined) {
                    return planSyncTransformation(ctx, (function (input) {
                                  var value = Caml_option.some(input);
                                  return fn(value);
                                }));
                  } else {
                    return planSyncTransformation(ctx, (function (input) {
                                  return Caml_option.some(input);
                                }));
                  }
                }),
              r: 0,
              e: 0,
              s: initialSerialize,
              p: intitialParse,
              a: intitialParseAsync,
              i: undefined,
              m: undefined
            }, metadataId$2, /* WithDefaultValue */{
              _0: defaultValue
            });
}

function classify$3(struct) {
  return get(struct, metadataId$2);
}

function factory$16(param) {
  var structs = (Array.from(arguments));
  var numberOfStructs = structs.length;
  return {
          n: "Tuple",
          t: {
            TAG: /* Tuple */5,
            _0: structs
          },
          pf: (function (ctx, struct) {
              var noopOps = [];
              var syncOps = [];
              var asyncOps = [];
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                var innerStruct = structs[idx];
                var fn = getParseOperation(innerStruct);
                if (typeof fn === "number") {
                  noopOps.push(idx);
                } else if (fn.TAG === /* SyncOperation */0) {
                  syncOps.push([
                        idx,
                        fn._0
                      ]);
                } else {
                  syncOps.push([
                        idx,
                        fn._0
                      ]);
                  asyncOps.push(idx);
                }
              }
              var withAsyncOps = asyncOps.length > 0;
              planSyncTransformation(ctx, (function (input) {
                      if (Array.isArray(input)) {
                        var numberOfInputItems = input.length;
                        if (numberOfStructs !== numberOfInputItems) {
                          raise$1({
                                TAG: /* TupleSize */3,
                                expected: numberOfStructs,
                                received: numberOfInputItems
                              });
                        }
                        
                      } else {
                        raiseUnexpectedTypeError(input, struct);
                      }
                      var newArray = [];
                      for(var idx = 0 ,idx_finish = syncOps.length; idx < idx_finish; ++idx){
                        var match = syncOps[idx];
                        var originalIdx = match[0];
                        var innerData = input[originalIdx];
                        try {
                          var value = match[1](innerData);
                          newArray[originalIdx] = value;
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            throw {
                                  RE_EXN_ID: Exception,
                                  _1: prependLocation(internalError._1, idx.toString()),
                                  Error: new Error()
                                };
                          }
                          throw internalError;
                        }
                      }
                      for(var idx$1 = 0 ,idx_finish$1 = noopOps.length; idx$1 < idx_finish$1; ++idx$1){
                        var originalIdx$1 = noopOps[idx$1];
                        var innerData$1 = input[originalIdx$1];
                        newArray[originalIdx$1] = innerData$1;
                      }
                      if (withAsyncOps) {
                        return newArray;
                      } else if (numberOfStructs !== 0) {
                        if (numberOfStructs !== 1) {
                          return newArray;
                        } else {
                          return newArray[0];
                        }
                      } else {
                        return ;
                      }
                    }));
              if (withAsyncOps) {
                return planAsyncTransformation(ctx, (function (tempArray) {
                              return Promise.all(asyncOps.map(function (originalIdx) {
                                                return tempArray[originalIdx]().catch(function (exn) {
                                                            throw exn.RE_EXN_ID === Exception ? ({
                                                                      RE_EXN_ID: Exception,
                                                                      _1: prependLocation(exn._1, originalIdx.toString())
                                                                    }) : exn;
                                                          });
                                              })).then(function (values) {
                                          values.forEach(function (value, idx) {
                                                var originalIdx = asyncOps[idx];
                                                tempArray[originalIdx] = value;
                                              });
                                          if (tempArray.length <= 1) {
                                            return tempArray[0];
                                          } else {
                                            return tempArray;
                                          }
                                        });
                            }));
              }
              
            }),
          sf: (function (ctx, param) {
              var serializeOperations = [];
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                serializeOperations.push(getSerializeOperation(structs[idx]));
              }
              planSyncTransformation(ctx, (function (input) {
                      var inputArray = numberOfStructs === 1 ? [input] : input;
                      var newArray = [];
                      for(var idx = 0 ,idx_finish = serializeOperations.length; idx < idx_finish; ++idx){
                        var innerData = inputArray[idx];
                        var serializeOperation = serializeOperations[idx];
                        if (serializeOperation !== undefined) {
                          try {
                            var value = serializeOperation(innerData);
                            newArray.push(value);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              throw {
                                    RE_EXN_ID: Exception,
                                    _1: prependLocation(internalError._1, idx.toString()),
                                    Error: new Error()
                                  };
                            }
                            throw internalError;
                          }
                        } else {
                          newArray.push(innerData);
                        }
                      }
                      return newArray;
                    }));
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

var Tuple = {
  factory: factory$16
};

var HackyValidValue = /* @__PURE__ */Caml_exceptions.create("S-ReScriptStruct.Union.HackyValidValue");

function factory$17(structs) {
  if (structs.length < 2) {
    throw new Error("[rescript-struct] A Union struct factory require at least two structs.");
  }
  return {
          n: "Union",
          t: {
            TAG: /* Union */6,
            _0: structs
          },
          pf: (function (ctx, compilingStruct) {
              var structs = compilingStruct.t._0;
              var noopOps = [];
              var syncOps = [];
              var asyncOps = [];
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                var innerStruct = structs[idx];
                var fn = getParseOperation(innerStruct);
                if (typeof fn === "number") {
                  noopOps.push(undefined);
                } else if (fn.TAG === /* SyncOperation */0) {
                  syncOps.push([
                        idx,
                        fn._0
                      ]);
                } else {
                  asyncOps.push([
                        idx,
                        fn._0
                      ]);
                }
              }
              var withAsyncOps = asyncOps.length > 0;
              if (noopOps.length === 0) {
                planSyncTransformation(ctx, (function (input) {
                        var idxRef = 0;
                        var errorsRef = [];
                        var maybeNewValueRef;
                        while(idxRef < syncOps.length && maybeNewValueRef === undefined) {
                          var idx = idxRef;
                          var match = syncOps[idx];
                          try {
                            var newValue = match[1](input);
                            maybeNewValueRef = Caml_option.some(newValue);
                          }
                          catch (raw_internalError){
                            var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                            if (internalError.RE_EXN_ID === Exception) {
                              errorsRef[match[0]] = internalError._1;
                              idxRef = idxRef + 1;
                            } else {
                              throw internalError;
                            }
                          }
                        };
                        var match$1 = maybeNewValueRef;
                        if (match$1 !== undefined) {
                          if (withAsyncOps) {
                            return {
                                    maybeSyncValue: match$1,
                                    tempErrors: errorsRef,
                                    originalInput: input
                                  };
                          } else {
                            return Caml_option.valFromOption(match$1);
                          }
                        } else if (withAsyncOps) {
                          return {
                                  maybeSyncValue: match$1,
                                  tempErrors: errorsRef,
                                  originalInput: input
                                };
                        } else {
                          return raise$1({
                                      TAG: /* InvalidUnion */5,
                                      _0: errorsRef.map(toParseError)
                                    });
                        }
                      }));
                if (withAsyncOps) {
                  return planAsyncTransformation(ctx, (function (input) {
                                var syncValue = input.maybeSyncValue;
                                if (syncValue !== undefined) {
                                  return Promise.resolve(Caml_option.valFromOption(syncValue));
                                } else {
                                  return Promise.all(asyncOps.map(function (param) {
                                                    var originalIdx = param[0];
                                                    try {
                                                      return param[1](input.originalInput)().then((function (value) {
                                                                    throw {
                                                                          RE_EXN_ID: HackyValidValue,
                                                                          _1: value,
                                                                          Error: new Error()
                                                                        };
                                                                  }), (function (exn) {
                                                                    if (exn.RE_EXN_ID === Exception) {
                                                                      var array = input.tempErrors;
                                                                      array[originalIdx] = exn._1;
                                                                      return ;
                                                                    }
                                                                    throw exn;
                                                                  }));
                                                    }
                                                    catch (raw_internalError){
                                                      var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                                                      if (internalError.RE_EXN_ID === Exception) {
                                                        var array = input.tempErrors;
                                                        return Promise.resolve((array[originalIdx] = internalError._1, undefined));
                                                      }
                                                      throw internalError;
                                                    }
                                                  })).then((function (param) {
                                                return raise$1({
                                                            TAG: /* InvalidUnion */5,
                                                            _0: input.tempErrors.map(toParseError)
                                                          });
                                              }), (function (exn) {
                                                if (exn.RE_EXN_ID === HackyValidValue) {
                                                  return exn._1;
                                                }
                                                throw exn;
                                              }));
                                }
                              }));
                } else {
                  return ;
                }
              }
              
            }),
          sf: (function (ctx, param) {
              var serializeOperations = [];
              for(var idx = 0 ,idx_finish = structs.length; idx < idx_finish; ++idx){
                serializeOperations.push(getSerializeOperation(structs[idx]));
              }
              planSyncTransformation(ctx, (function (input) {
                      var idxRef = 0;
                      var errors = [];
                      var maybeNewValueRef;
                      while(idxRef < serializeOperations.length && maybeNewValueRef === undefined) {
                        var idx = idxRef;
                        var serializeOperation = serializeOperations[idx];
                        try {
                          var newValue = serializeOperation !== undefined ? serializeOperation(input) : input;
                          maybeNewValueRef = Caml_option.some(newValue);
                        }
                        catch (raw_internalError){
                          var internalError = Caml_js_exceptions.internalToOCamlException(raw_internalError);
                          if (internalError.RE_EXN_ID === Exception) {
                            errors.push(internalError._1);
                            idxRef = idxRef + 1;
                          } else {
                            throw internalError;
                          }
                        }
                      };
                      var ok = maybeNewValueRef;
                      if (ok !== undefined) {
                        return Caml_option.valFromOption(ok);
                      } else {
                        return raise$1({
                                    TAG: /* InvalidUnion */5,
                                    _0: errors.map(toSerializeError)
                                  });
                      }
                    }));
            }),
          r: 0,
          e: 0,
          s: initialSerialize,
          p: intitialParse,
          a: intitialParseAsync,
          i: undefined,
          m: undefined
        };
}

function getExn(result) {
  if (result.TAG === /* Ok */0) {
    return result._0;
  }
  var message = toString(result._0);
  throw new Error("[rescript-struct] " + message + "");
}

function mapErrorToString(result) {
  if (result.TAG === /* Ok */0) {
    return result;
  } else {
    return {
            TAG: /* Error */1,
            _0: toString(result._0)
          };
  }
}

var Result = {
  getExn: getExn,
  mapErrorToString: mapErrorToString
};

var $$Error$1 = {
  prependLocation: prependLocation$1,
  raiseCustom: raiseCustom,
  raise: raise$2,
  toString: toString
};

var never = factory$3;

var unknown = factory$4;

var string = factory$5;

var bool = factory$7;

var $$int = factory$8;

var $$float = factory$9;

var literal = factory$1;

var literalVariant = factory;

var array = factory$13;

var dict = factory$14;

var option = factory$11;

var $$null = factory$10;

var json = factory$6;

var union = factory$17;

var deprecated = factory$12;

var defaulted = factory$15;

var Object_UnknownKeys = {
  classify: classify$1
};

var $$Object = {
  UnknownKeys: Object_UnknownKeys,
  strip: strip,
  strict: strict
};

var object = factory$2;

var tuple0 = factory$16;

var tuple1 = factory$16;

var tuple2 = factory$16;

var tuple3 = factory$16;

var tuple4 = factory$16;

var tuple5 = factory$16;

var tuple6 = factory$16;

var tuple7 = factory$16;

var tuple8 = factory$16;

var tuple9 = factory$16;

var tuple10 = factory$16;

var $$String = {
  min: min,
  max: max,
  length: length,
  email: email,
  uuid: uuid,
  cuid: cuid,
  url: url,
  pattern: pattern,
  trimmed: trimmed
};

var Int = {
  min: min$1,
  max: max$1,
  port: port
};

var Float = {
  min: min$1,
  max: max$1
};

var $$Array = {
  min: min$2,
  max: max$2,
  length: length$1
};

var Defaulted = {
  classify: classify$3
};

var Deprecated = {
  classify: classify$2
};

var Metadata = {
  Id: Id,
  get: get,
  set: set
};

exports.$$Error = $$Error$1;
exports.Raised = Raised;
exports.never = never;
exports.unknown = unknown;
exports.string = string;
exports.bool = bool;
exports.$$int = $$int;
exports.$$float = $$float;
exports.literal = literal;
exports.literalVariant = literalVariant;
exports.array = array;
exports.dict = dict;
exports.option = option;
exports.$$null = $$null;
exports.json = json;
exports.union = union;
exports.deprecated = deprecated;
exports.defaulted = defaulted;
exports.transform = transform;
exports.advancedTransform = advancedTransform;
exports.advancedPreprocess = advancedPreprocess;
exports.custom = custom;
exports.refine = refine;
exports.asyncRefine = asyncRefine;
exports.parseWith = parseWith;
exports.parseOrRaiseWith = parseOrRaiseWith;
exports.parseAsyncWith = parseAsyncWith;
exports.parseAsyncInStepsWith = parseAsyncInStepsWith;
exports.serializeWith = serializeWith;
exports.serializeOrRaiseWith = serializeOrRaiseWith;
exports.isAsyncParse = isAsyncParse;
exports.recursive = recursive;
exports.asyncRecursive = asyncRecursive;
exports.$$Object = $$Object;
exports.object = object;
exports.field = field;
exports.discriminant = discriminant;
exports.Tuple = Tuple;
exports.tuple0 = tuple0;
exports.tuple1 = tuple1;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.tuple5 = tuple5;
exports.tuple6 = tuple6;
exports.tuple7 = tuple7;
exports.tuple8 = tuple8;
exports.tuple9 = tuple9;
exports.tuple10 = tuple10;
exports.classify = classify;
exports.name = name;
exports.$$String = $$String;
exports.Int = Int;
exports.Float = Float;
exports.$$Array = $$Array;
exports.Defaulted = Defaulted;
exports.Deprecated = Deprecated;
exports.Result = Result;
exports.Metadata = Metadata;
/* value Not a pure module */
